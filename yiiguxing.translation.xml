<application>
  <component name="AppStorage">
    <histories>
      <item value="Reason: Failed to determine a suitable driver class" />
      <item value="Participate in LiveBeansView MBean, if active." />
      <item value="Instantiate all remaining (non-lazy-init) singletons." />
      <item value="DRIVER" />
      <item value="Unpooled" />
      <item value=" Unpooled" />
      <item value="Registry" />
      <item value="Reflector" />
      <item value="synchronized (type) removed see issue 461" />
      <item value=" we also need to look for interface methods -&#10;       because the class may be abstract" />
      <item value="    This is added to enable basic support for the&#10;    ARRAY data type - but a custom type handler is still required" />
      <item value="Transaction" />
      <item value="Resolver" />
      <item value="Alias" />
      <item value="important: this must only be called AFTER common constructor" />
      <item value="Provider" />
      <item value="reactor" />
      <item value="Object org.apache.ibatis.plugin.Invocation.proceed()" />
      <item value="Undefined reference" />
      <item value="Re-run Maven using the -X switch to enable full debug logging." />
      <item value="If the parameter String was &quot;v1 v2 v3&quot; then make sure to stitch it back" />
      <item value="unable to find valid certification path to requested target" />
      <item value="offline" />
      <item value="You are using an offline license." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="26" />
        <entry key="ENGLISH" value="27" />
        <entry key="PORTUGUESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1665191589737" />
  </component>
  <component name="Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20220930001362687" />
      </app-key>
    </option>
    <option name="keepFormat" value="true" />
    <option name="showActionsInContextMenuOnlyWithSelection" value="false" />
    <option name="translateDocumentation" value="true" />
    <option name="translator" value="BAIDU" />
  </component>
  <component name="Translation.Cache">
    <option name="lastTrimTime" value="1675043751378" />
  </component>
  <component name="Translation.Settings">
    <option name="aliTranslateSettings">
      <app-key>
        <option name="appId" value="LTAI5tBUaVzvfC6xCZ72gUrc" />
      </app-key>
    </option>
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20220930001362687" />
      </app-key>
    </option>
    <option name="primaryLanguage" value="CHINESE" />
    <option name="translator" value="ALI" />
  </component>
  <component name="Translation.States">
    <option name="newTranslationDialogWidth" value="598" />
    <option name="newTranslationDialogX" value="813" />
    <option name="newTranslationDialogY" value="448" />
    <histories>
      <item value="We need to create a method invocation..." />
      <item value="Choose an &quot;aop&quot; interceptor (used for AOP calls)." />
      <item value="If we get here, we need to create a MethodInvocation." />
      <item value="fixedInterceptorMap only populated at this point, after getCallbacks call above" />
      <item value="Check if we have a cached item matching the conditions" />
      <item value="Directly propagate ThrowableWrapper from the invoker, or potentially also an IllegalArgumentException etc." />
      <item value="Special handling of synchronized invocation" />
      <item value="No caching required, only call the underlying method" />
      <item value="Collect any explicit @CachePuts" />
      <item value="Validate the class, writing log messages as necessary." />
      <item value="Advisor" />
      <item value="Does the actual (non-CGLIB) superclass implement BeanFactoryAware? If so, call its setBeanFactory() method. If not, just exit." />
      <item value="Aware" />
      <item value="Propagate original exception if declared on the target method (with callers expecting it). Always propagate it for Kotlin code since checked exceptions do not have to be explicitly declared there." />
      <item value="Advice" />
      <item value="Pointcut" />
      <item value="should never be invoked because isRuntime() returns false" />
      <item value="Eligible" />
      <item value="Fall" />
      <item value="The method may be on an interface, but we need attributes from the target class. If the target class is null, the method will be unchanged." />
      <item value="Retrieval" />
      <item value="J Expression" />
      <item value="If it's a per target aspect, emit the dummy instantiating aspect." />
      <item value="Build Advisors for all AspectJ aspects in the bean factory." />
      <item value="Add all the Spring advisors found according to superclass rules." />
      <item value="Per target or per this." />
      <item value="Capable" />
      <item value="custom" />
      <item value="predict Bean Type" />
      <item value="Previously we setProxyTargetClass(true) in the constructor, but that has too broad an impact. Instead we now override isInfrastructureClass to avoid proxying aspects. I'm not entirely happy with that as there is no good reason not to advise aspects, except that it causes advice invocation to go through a proxy, and if the aspect implements e.g the Ordered interface it will be proxied by that interface and fail at runtime as the advice method is not defined on the interface. We could potentially relax the restriction about not advising aspects in the future." />
      <item value="Consider optimization by caching the list of the aspect names" />
      <item value="Aspect" />
      <item value="attempt to unlock lock, not locked by current thread by node id: bbb036fc-4975-471d-b383-5e6616a8a655 thread-id: 327" />
      <item value="Use getLock method instead. Returned instance uses Redis Slave synchronization" />
      <item value="super" />
      <item value="unresolved" />
      <item value="Running in an ApplicationContext -&gt; register tasks this late... giving other ContextRefreshedEvent listeners a chance to perform their work at the same time (e.g. Spring Batch's job registration)." />
      <item value="A notification that the bean definition for the specified name has been reset, and that this post-processor should clear any metadata for the affected bean. The default implementation is empty." />
      <item value="Read Operation" />
      <item value="Operation" />
      <item value="Skipping currently created advisor" />
      <item value="Do not initialize FactoryBeans here: We need to leave all regular beans uninitialized to let the auto-proxy creator apply to them!" />
      <item value="Determine list of advisor bean names, if not cached already." />
      <item value="Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor." />
      <item value="Create proxy if we have advice." />
      <item value="No CacheResolver specified, and no bean of type CacheManager found." />
      <item value="Handle prototypes correctly..." />
      <item value="Give BeanPostProcessors a chance to return a proxy instead of the target bean instance." />
      <item value="Dynamic matching failed. Skip this interceptor and invoke the next in the chain." />
      <item value="Deferred" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="30" />
        <entry key="ENGLISH" value="30" />
      </map>
    </option>
  </component>
</application>